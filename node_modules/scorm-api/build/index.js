'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _config = require('./config');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scorm = function () {
    function Scorm(commitHandler, finishHandler) {
        _classCallCheck(this, Scorm);

        this.cmi = {};
        this.errorCode = '0';
        this.commitHandler = commitHandler;
        this.finishHandler = finishHandler;
    }

    _createClass(Scorm, [{
        key: 'LMSInitialize',
        value: function LMSInitialize() {
            this.errorCode = '0';
            return 'true';
        }
    }, {
        key: 'LMSFinish',
        value: function LMSFinish() {
            this.errorCode = '0';
            this.finishHandler();
            return 'true';
        }
    }, {
        key: 'LMSGetValue',
        value: function LMSGetValue(element) {
            this.errorCode = '0';

            var baseObject = this.getBase(element, this);
            var lastChild = element.split('.').pop();
            var value = baseObject[lastChild];

            return value ? value : '';
        }
    }, {
        key: 'LMSSetValue',
        value: function LMSSetValue(element, value) {
            this.errorCode = '0';

            // setting the root element is not allowed
            if (element.split('.').length < 2) {
                this.errorCode = '201';
                return 'false';
            }

            var baseObject = this.getBase(element, this);
            var lastNode = element.split('.').pop();
            baseObject[lastNode] = value;

            return "true";
        }
    }, {
        key: 'LMSCommit',
        value: function LMSCommit() {
            this.commitHandler(this.flatten({ cmi: this.cmi }));
        }
    }, {
        key: 'LMSGetLastError',
        value: function LMSGetLastError() {
            return this.errorCode;
        }
    }, {
        key: 'LMSGetErrorString',
        value: function LMSGetErrorString(param) {
            return param !== '' ? _config.errorString[param] : '';
        }
    }, {
        key: 'LMSGetDiagnostic',
        value: function LMSGetDiagnostic() {
            return '';
        }
    }, {
        key: 'init',
        value: function init(cmi) {
            this.cmi = cmi;
        }

        // e.g. data = [{"element": "cmi.suspend_data","value":"Hi"}];

    }, {
        key: 'parse',
        value: function parse(data) {
            var _this = this;

            var holder = {};
            data.forEach(function (entry) {
                var nodes = entry.element.split('.');
                var lastNode = nodes.pop();
                var baseObject = _this.getBase(entry.element, holder);

                baseObject[lastNode] = entry.value;
            });
            return holder.cmi;
        }

        // this returns non-null base object of the path given
        // e.g. cmi.core.score.raw -> non-null cmi.core.score

    }, {
        key: 'getBase',
        value: function getBase(element, scope) {
            var nodes = element.split('.');
            // to get base, remove the last element
            nodes.pop();

            // make sure the return object is non-null
            return nodes.reduce(function (obj, key) {
                obj[key] = obj[key] || {};
                return obj[key];
            }, scope);
        }
    }, {
        key: 'flatten',
        value: function flatten(o) {
            var toReturn = {};

            for (var i in o) {
                if (!o.hasOwnProperty(i)) continue;

                if (_typeof(o[i]) == 'object') {
                    var flatObject = this.flatten(o[i]);
                    for (var x in flatObject) {
                        if (!flatObject.hasOwnProperty(x)) continue;

                        toReturn[i + '.' + x] = flatObject[x];
                    }
                } else {
                    toReturn[i] = o[i];
                }
            }
            return toReturn;
        }
    }]);

    return Scorm;
}();

exports.default = Scorm;